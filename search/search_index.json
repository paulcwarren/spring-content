{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Content Services for Spring Cloud-Native Content Management Extensions for Spring. For creating cloud-native, horizontally scaling Content Management Services that manage your unstructured data and rich content such as documents, images and movies. Features Standardized access to content no matter where it is stored Associate content with Spring Data entities Reactive content access (S3) Full-text search (Solr and Elasticsearch) Content rendition and transformation Pessimistic versioning or auto-versioning REST or CMIS endpoints Videos An Overview of Spring Content SpringOne 2016 - Persistence Arrives on Cloud Foundry SpringOne 2017 - A Guided Tour From Code Base To Platform 11:28 - 21:58 SpringOne 2018 - From Content Management to Content Services with Spring Boot, Data and Content Modules Commons - Core content management concepts underpinning every other module S3 - Store support for Amazon S3, and any other S3-compliant object storage. Also supports reactive access. Filesystem - Store support for the Filesystem storage Mongo - Store support for Mongo's GridFS storage JPA - Store support for JPA BLOB storage Renditions - Extensible rendition service for content transformations Solr - Content indexing and search with Apache Solr Elasticsearch - Content indexing and search with Elasticsearch Versions Commons - Locking and versioning semantics for Entities and associated content Versions JPA - JPA-based implementation of locking and versioning REST - Exports Stores as hypermedia-driven RESTful resources CMIS - Exports Stores through the CMIS browser bindings Overview Figure 1. understanding how Spring Content fits into the Spring eco-system Quick Start <dependency> <groupId>com.github.paulcwarren</groupId> <artifactId>spring-content-fs-boot-starter</artifactId> <version>3.0.12</version> </dependency> For a quick taste, look at the following domain object: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/File.java 17-33} This defines a simple JPA entity with a few structured data fields; title, authors and keywords and two Spring Content-managed data fields; @ContentId and @ContentLength . The structured data fields are managed in the usual way through a CrudRepository<SopDocument,String> interface. Content is handled separately with a ContentStore interface:- {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 5-6} This interface extends Spring Content\u2019s ContentStore and is typed to the entity class File and the id class String. Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-fs-boot-starter like this: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 6-12} Launch your app and Spring Content (having been autoconfigured by Spring Boot) will automatically craft a concrete set of operations for handling the content associated with this Entity: S setContent(S entity, InputStream content) InputStream getContent(S entity) S unsetContent(S entity) For more, check out our initial Getting Started Guide , or watch one of our SpringOne talks 2016 , 2017 @11mins and 2018 . Reference Documentation Boot 2.4.x+ Boot 3.0.x+ GA SNAPSHOT GA SNAPSHOT Storage Spring Content S3 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content GCS 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Azure Storage 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Filesystem 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Mongo (GridFS) 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content JPA 2.9.0 2.10.0 3.0.12 3.0.13 Renditions Spring Content Renditions 2.9.0 2.10.0 3.0.12 3.0.13 Versioning Spring Versions JPA 2.9.0 2.10.0 3.0.12 3.0.13 Fulltext Indexing Spring Content Solr 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Elasticsearch 2.9.0 2.10.0 3.0.12 3.0.13 APIs Spring Content REST 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content CMIS 2.9.0 2.10.0 3.0.12 3.0.13","title":"Home"},{"location":"#content-services-for-spring","text":"Cloud-Native Content Management Extensions for Spring. For creating cloud-native, horizontally scaling Content Management Services that manage your unstructured data and rich content such as documents, images and movies.","title":"Content Services for Spring"},{"location":"#features","text":"Standardized access to content no matter where it is stored Associate content with Spring Data entities Reactive content access (S3) Full-text search (Solr and Elasticsearch) Content rendition and transformation Pessimistic versioning or auto-versioning REST or CMIS endpoints","title":"Features"},{"location":"#videos","text":"An Overview of Spring Content SpringOne 2016 - Persistence Arrives on Cloud Foundry SpringOne 2017 - A Guided Tour From Code Base To Platform 11:28 - 21:58 SpringOne 2018 - From Content Management to Content Services with Spring Boot, Data and Content","title":"Videos"},{"location":"#modules","text":"Commons - Core content management concepts underpinning every other module S3 - Store support for Amazon S3, and any other S3-compliant object storage. Also supports reactive access. Filesystem - Store support for the Filesystem storage Mongo - Store support for Mongo's GridFS storage JPA - Store support for JPA BLOB storage Renditions - Extensible rendition service for content transformations Solr - Content indexing and search with Apache Solr Elasticsearch - Content indexing and search with Elasticsearch Versions Commons - Locking and versioning semantics for Entities and associated content Versions JPA - JPA-based implementation of locking and versioning REST - Exports Stores as hypermedia-driven RESTful resources CMIS - Exports Stores through the CMIS browser bindings","title":"Modules"},{"location":"#overview","text":"Figure 1. understanding how Spring Content fits into the Spring eco-system","title":"Overview"},{"location":"#quick-start","text":"<dependency> <groupId>com.github.paulcwarren</groupId> <artifactId>spring-content-fs-boot-starter</artifactId> <version>3.0.12</version> </dependency> For a quick taste, look at the following domain object: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/File.java 17-33} This defines a simple JPA entity with a few structured data fields; title, authors and keywords and two Spring Content-managed data fields; @ContentId and @ContentLength . The structured data fields are managed in the usual way through a CrudRepository<SopDocument,String> interface. Content is handled separately with a ContentStore interface:- {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 5-6} This interface extends Spring Content\u2019s ContentStore and is typed to the entity class File and the id class String. Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-fs-boot-starter like this: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 6-12} Launch your app and Spring Content (having been autoconfigured by Spring Boot) will automatically craft a concrete set of operations for handling the content associated with this Entity: S setContent(S entity, InputStream content) InputStream getContent(S entity) S unsetContent(S entity) For more, check out our initial Getting Started Guide , or watch one of our SpringOne talks 2016 , 2017 @11mins and 2018 .","title":"Quick Start"},{"location":"#reference-documentation","text":"Boot 2.4.x+ Boot 3.0.x+ GA SNAPSHOT GA SNAPSHOT Storage Spring Content S3 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content GCS 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Azure Storage 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Filesystem 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Mongo (GridFS) 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content JPA 2.9.0 2.10.0 3.0.12 3.0.13 Renditions Spring Content Renditions 2.9.0 2.10.0 3.0.12 3.0.13 Versioning Spring Versions JPA 2.9.0 2.10.0 3.0.12 3.0.13 Fulltext Indexing Spring Content Solr 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content Elasticsearch 2.9.0 2.10.0 3.0.12 3.0.13 APIs Spring Content REST 2.9.0 2.10.0 3.0.12 3.0.13 Spring Content CMIS 2.9.0 2.10.0 3.0.12 3.0.13","title":"Reference Documentation"},{"location":"spring-content-fs-docs/","text":"Getting Started with Spring Content What you'll build You'll build an application that uses Spring Content to build a simple web-based document list. What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there. How to complete this guide Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Build with Maven. To skip the basics, do the following: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git cd into spring-content-gettingstarted/spring-content-fs/initial Jump ahead to Define a simple entity . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-fs/complete . Build with Maven First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with Maven is included here. If you\u2019re not familiar with Maven, refer to Building Java Projects with Maven . Create a directory structure In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/gettingstarted on *nix systems: \u221f src \u221f main \u221f java \u221f gettingstarted \u221f resources \u221f static pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/pom.xml 1-} We add several dependencies:- Spring Boot Starter Web provides the web server framework Spring Boot Starter Data JPA will provide a relational database to store the metadata of our files. In this case we are using the H2 in-memory database Spring Boot Starter Data REST will provide REST endpoints for our File metadata Spring Boot Starter Content FS will provide a Filesystem-based store for the content of each file and manage the association with an Entity Define a simple Entity Let's define a simple Entity to represent a File. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/File.java 1-} As you would expect we created a standard JPA Entity to capture some metadata about our file; name and summary . In addition, because we will be serving these files over the web, we also record mimeType so that we can instruct the browser correctly. We then add two annotated Spring Content fields; @ContentId and @ContentLength . @ContentId allows us to associate a stream of binary data with an Entity and @ContentLength records the length of that stream. These will be automatically managed by Spring Content. Create a File Repository Next, as you would also expect, we create a CrudRepository for handling File entities and we export it as a @RepositoryRestResource so, for the cost of writing just one interface and annotating it, we get the ability to create, read, update and delete File entities using REST endpoints. NB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io getting started guides. src/main/java/gettingstated/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileRepository.java 1-} Create a File Content Store Similarly, we then create a ContentStore for handling content associated with the File entity. src/main/java/gettngstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Let's investigate this interface:- ContentStore provides several methods for handling content; setContent, getContent and unsetContent The dependency com.github.paulcwarren:spring-content-fs-boot-starter provides a Filesystem-based implementation of this interface and Spring Content auto-configuration ensures that this implementation will be used wherever the FileContentRepository is @Autowired . However, unlike our FileRepository we haven't annotated this as a StoreRestResource and therefore we don't automatically get REST endpoints for handling content. This annotation does exist (and is the topic of our next tutorial ) but, for now, we have to roll our own REST endpoints. Create a File Controller Let's create these endpoints with a simple Controller class. src/main/java/gettingstarted/FileContentController.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileContentController.java 1-} Let's explain this class. It's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content. Both setContent and getContent methods inject themselves into the URI space of the FileRepository , namely /files/{fileId} , but handle all GETs and PUTs that are aplication/hal+json based; i.e. content. We inject our FileRepository and our FileContentStore . Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path). setContent uses the FileRepository to fetch the File entity using the given fileId and then uses the FileContentStore to save the given file input stream. Similarly, getContent uses the FileRepository to fetch the File entity using the given fileId and again use the FileContentStore to fetch the associated content and stream it back to the client as the response. We also use previosuly saved metdata contentLength and mimeType to set http headers appropriately. This will mean that browsers can handle the content correctly by launching the relevant desktop application. Create Web Client Now let's create a really simple angular web front-end for our document list. src/main/resources/static/index.html {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/resources/static/index.html 1-} This HTML presents a simple list of files using an ng-repeat directive and contains a simple form allowing new files to be uploaded. All the interesting code is in the code-behind file so add the following code behind to src/main/resources/static/files.js {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/resources/static/files.js 1-} This angular controller has the following functions:- getFilesList queries our FileRepository via its REST endpoint files/ and populates filesList.files (presented by the ng-repeat directive in the HTML) getHref returns a file 's content hyperlink files/{fileId} (that ultimately calls FileContentController.getContent ) upload uploads a new File by first POST ing to the FileRepository REST endpoints /files and once created PUT ing the actual content to the Files content REST endpoint files/{fileId} (that ultimately calls FileContentController.setContent ) Create an Application class Our simple document list app is now complete. All that remains is to add the usual Spring Boot Application class. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-fs-0.0.1.jar And then point your browser at:- http://localhost:8080 and you should see something like this:- Exercise the application by uploading a range of new files and viewing them. Viewed files will be downloaded and open in the appropriate editor. Summary Congratulations! You\u2019ve written a simple application that uses Spring Content to manage streams of binary data - without writing any specific file access code. What's more by just changing the type of the spring-content boot-starter project on the classpath you can switch from a file-based implementation to a different implementation altogether. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS Look Forward In this tutorial we built a simple document list web application using Spring Content. The majority of the work on the server-side was writing the Spring controller for handling the Content. Check out our next getting started guide where we'll use the companion library Spring Content REST to automatically export these REST endpoints for our FileContentStore saving ourselves even more work.","title":"Java API"},{"location":"spring-content-fs-docs/#getting-started-with-spring-content","text":"","title":"Getting Started with Spring Content"},{"location":"spring-content-fs-docs/#what-youll-build","text":"You'll build an application that uses Spring Content to build a simple web-based document list.","title":"What you'll build"},{"location":"spring-content-fs-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.","title":"What you'll need"},{"location":"spring-content-fs-docs/#how-to-complete-this-guide","text":"Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Build with Maven. To skip the basics, do the following: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git cd into spring-content-gettingstarted/spring-content-fs/initial Jump ahead to Define a simple entity . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-fs/complete .","title":"How to complete this guide"},{"location":"spring-content-fs-docs/#build-with-maven","text":"First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with Maven is included here. If you\u2019re not familiar with Maven, refer to Building Java Projects with Maven .","title":"Build with Maven"},{"location":"spring-content-fs-docs/#create-a-directory-structure","text":"In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/gettingstarted on *nix systems: \u221f src \u221f main \u221f java \u221f gettingstarted \u221f resources \u221f static pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/pom.xml 1-} We add several dependencies:- Spring Boot Starter Web provides the web server framework Spring Boot Starter Data JPA will provide a relational database to store the metadata of our files. In this case we are using the H2 in-memory database Spring Boot Starter Data REST will provide REST endpoints for our File metadata Spring Boot Starter Content FS will provide a Filesystem-based store for the content of each file and manage the association with an Entity","title":"Create a directory structure"},{"location":"spring-content-fs-docs/#define-a-simple-entity","text":"Let's define a simple Entity to represent a File. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/File.java 1-} As you would expect we created a standard JPA Entity to capture some metadata about our file; name and summary . In addition, because we will be serving these files over the web, we also record mimeType so that we can instruct the browser correctly. We then add two annotated Spring Content fields; @ContentId and @ContentLength . @ContentId allows us to associate a stream of binary data with an Entity and @ContentLength records the length of that stream. These will be automatically managed by Spring Content.","title":"Define a simple Entity"},{"location":"spring-content-fs-docs/#create-a-file-repository","text":"Next, as you would also expect, we create a CrudRepository for handling File entities and we export it as a @RepositoryRestResource so, for the cost of writing just one interface and annotating it, we get the ability to create, read, update and delete File entities using REST endpoints. NB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io getting started guides. src/main/java/gettingstated/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileRepository.java 1-}","title":"Create a File Repository"},{"location":"spring-content-fs-docs/#create-a-file-content-store","text":"Similarly, we then create a ContentStore for handling content associated with the File entity. src/main/java/gettngstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Let's investigate this interface:- ContentStore provides several methods for handling content; setContent, getContent and unsetContent The dependency com.github.paulcwarren:spring-content-fs-boot-starter provides a Filesystem-based implementation of this interface and Spring Content auto-configuration ensures that this implementation will be used wherever the FileContentRepository is @Autowired . However, unlike our FileRepository we haven't annotated this as a StoreRestResource and therefore we don't automatically get REST endpoints for handling content. This annotation does exist (and is the topic of our next tutorial ) but, for now, we have to roll our own REST endpoints.","title":"Create a File Content Store"},{"location":"spring-content-fs-docs/#create-a-file-controller","text":"Let's create these endpoints with a simple Controller class. src/main/java/gettingstarted/FileContentController.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/FileContentController.java 1-} Let's explain this class. It's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content. Both setContent and getContent methods inject themselves into the URI space of the FileRepository , namely /files/{fileId} , but handle all GETs and PUTs that are aplication/hal+json based; i.e. content. We inject our FileRepository and our FileContentStore . Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path). setContent uses the FileRepository to fetch the File entity using the given fileId and then uses the FileContentStore to save the given file input stream. Similarly, getContent uses the FileRepository to fetch the File entity using the given fileId and again use the FileContentStore to fetch the associated content and stream it back to the client as the response. We also use previosuly saved metdata contentLength and mimeType to set http headers appropriately. This will mean that browsers can handle the content correctly by launching the relevant desktop application.","title":"Create a File Controller"},{"location":"spring-content-fs-docs/#create-web-client","text":"Now let's create a really simple angular web front-end for our document list. src/main/resources/static/index.html {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/resources/static/index.html 1-} This HTML presents a simple list of files using an ng-repeat directive and contains a simple form allowing new files to be uploaded. All the interesting code is in the code-behind file so add the following code behind to src/main/resources/static/files.js {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/resources/static/files.js 1-} This angular controller has the following functions:- getFilesList queries our FileRepository via its REST endpoint files/ and populates filesList.files (presented by the ng-repeat directive in the HTML) getHref returns a file 's content hyperlink files/{fileId} (that ultimately calls FileContentController.getContent ) upload uploads a new File by first POST ing to the FileRepository REST endpoints /files and once created PUT ing the actual content to the Files content REST endpoint files/{fileId} (that ultimately calls FileContentController.setContent )","title":"Create Web Client"},{"location":"spring-content-fs-docs/#create-an-application-class","text":"Our simple document list app is now complete. All that remains is to add the usual Spring Boot Application class. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-}","title":"Create an Application class"},{"location":"spring-content-fs-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-fs-0.0.1.jar And then point your browser at:- http://localhost:8080 and you should see something like this:- Exercise the application by uploading a range of new files and viewing them. Viewed files will be downloaded and open in the appropriate editor.","title":"Build an executable JAR"},{"location":"spring-content-fs-docs/#summary","text":"Congratulations! You\u2019ve written a simple application that uses Spring Content to manage streams of binary data - without writing any specific file access code. What's more by just changing the type of the spring-content boot-starter project on the classpath you can switch from a file-based implementation to a different implementation altogether. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"},{"location":"spring-content-fs-docs/#look-forward","text":"In this tutorial we built a simple document list web application using Spring Content. The majority of the work on the server-side was writing the Spring controller for handling the Content. Check out our next getting started guide where we'll use the companion library Spring Content REST to automatically export these REST endpoints for our FileContentStore saving ourselves even more work.","title":"Look Forward"},{"location":"spring-content-rest-docs/","text":"Getting Started with Spring Content REST What you'll build You'll remove redundant code from the document list web application that we produced in our first Getting Started Guide . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start form where we left of in the last Getting Started Guide so cd into spring-content-gettingstarted/spring-content-fs/complete Move ahead to Update dependencies . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-rest/complete . Update dependencies Add the com.github.paulcwarren:spring-content-rest-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-rest/complete/pom.xml 1-} Update File Entity Add the @MimeType marker annotation to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-rest/complete/src/main/java/gettingstarted/File.java 1-} The contentMimeType attribute is updated with the Spring Content @MimeType annotation so that Spring Content REST will update its value on our behalf. Update FileContentStore So that we can perform simple CRUD operations, over a hypermedia-based API, update our FileContentStore by annotating it with the @StoreRestResource Spring Content REST annotation. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-rest/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Remove FileContentController Having made the above updates we can remove our FileContentController as it is now surplus to requirements. Spring Content REST will provide these endpoints for us. Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-rest-0.0.1.jar Test the application And then point your browser at:- http://localhost:8080 and you should see something like this:- As you did in the previous tutorial, exercise the application by uploading a range of new files and viewing them. You should see viewed files open as they did before. Test the REST API Alternatively, you can test the REST API directly. First create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ You should recieve a response back from your service that looks something like the following: { \"name\" : null, \"created\" : \"2020-10-20T04:17:03.733+0000\", \"summary\" : null, \"contentId\" : null, \"contentLength\" : 0, \"mimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"content\" : { \"href\" : \"http://localhost:8080/files/1/content\" } } } Follow the content link relation to add content either using CURL: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1/content Or, if you prefer, by uploading the content via postman: NOTE Unlike the curl-based PUT example above this Postman request is specifying a multipart/form-data request and a form entry with a key of file and with the content of the file as the value. Spring Content REST supports PUT and POST requests with the Content-Type header set to the actual mimetype of the content, such as text/plain or with a content-type of multipart/form-data and a properly constructed multipart form. Lasty, verify the content was uploaded by requesting it again: curl -H 'Accept:text/plain' http://localhost:8080/files/1/content You should see you content returned as follows: Hello Spring Content World! Summary Congratulations! You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to the file-system and to fetch them again using a hypermedia-based REST API - all without writing any implementation code to handle file access. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage medium. Spring Content REST works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"REST API"},{"location":"spring-content-rest-docs/#getting-started-with-spring-content-rest","text":"","title":"Getting Started with Spring Content REST"},{"location":"spring-content-rest-docs/#what-youll-build","text":"You'll remove redundant code from the document list web application that we produced in our first Getting Started Guide .","title":"What you'll build"},{"location":"spring-content-rest-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-rest-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start form where we left of in the last Getting Started Guide so cd into spring-content-gettingstarted/spring-content-fs/complete Move ahead to Update dependencies . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-rest/complete .","title":"How to complete this guide"},{"location":"spring-content-rest-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-rest-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-rest/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-rest-docs/#update-file-entity","text":"Add the @MimeType marker annotation to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-rest/complete/src/main/java/gettingstarted/File.java 1-} The contentMimeType attribute is updated with the Spring Content @MimeType annotation so that Spring Content REST will update its value on our behalf.","title":"Update File Entity"},{"location":"spring-content-rest-docs/#update-filecontentstore","text":"So that we can perform simple CRUD operations, over a hypermedia-based API, update our FileContentStore by annotating it with the @StoreRestResource Spring Content REST annotation. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-rest/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-rest-docs/#remove-filecontentcontroller","text":"Having made the above updates we can remove our FileContentController as it is now surplus to requirements. Spring Content REST will provide these endpoints for us.","title":"Remove FileContentController"},{"location":"spring-content-rest-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-rest-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-rest-docs/#test-the-application","text":"And then point your browser at:- http://localhost:8080 and you should see something like this:- As you did in the previous tutorial, exercise the application by uploading a range of new files and viewing them. You should see viewed files open as they did before.","title":"Test the application"},{"location":"spring-content-rest-docs/#test-the-rest-api","text":"Alternatively, you can test the REST API directly. First create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ You should recieve a response back from your service that looks something like the following: { \"name\" : null, \"created\" : \"2020-10-20T04:17:03.733+0000\", \"summary\" : null, \"contentId\" : null, \"contentLength\" : 0, \"mimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"content\" : { \"href\" : \"http://localhost:8080/files/1/content\" } } } Follow the content link relation to add content either using CURL: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1/content Or, if you prefer, by uploading the content via postman: NOTE Unlike the curl-based PUT example above this Postman request is specifying a multipart/form-data request and a form entry with a key of file and with the content of the file as the value. Spring Content REST supports PUT and POST requests with the Content-Type header set to the actual mimetype of the content, such as text/plain or with a content-type of multipart/form-data and a properly constructed multipart form. Lasty, verify the content was uploaded by requesting it again: curl -H 'Accept:text/plain' http://localhost:8080/files/1/content You should see you content returned as follows: Hello Spring Content World!","title":"Test the REST API"},{"location":"spring-content-rest-docs/#summary","text":"Congratulations! You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to the file-system and to fetch them again using a hypermedia-based REST API - all without writing any implementation code to handle file access. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage medium. Spring Content REST works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"},{"location":"spring-content-with-cmis-docs/","text":"Getting Started with Spring Content and CMIS (Spring Content 2.x only - Deprecated) What you'll build You'll build a simple document management application using Spring Content and Spring Content CMIS. What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there. How to complete this guide Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Build with Maven. To skip the basics, do the following: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git cd into spring-content-gettingstarted/spring-content-with-cmis/initial Jump ahead to Define a simple entity . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-cmis/complete . Build with Maven First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with Maven is included here. If you\u2019re not familiar with Maven, refer to Building Java Projects with Maven . Create a directory structure In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/gettingstarted on *nix systems: \u221f src \u221f main \u221f java \u221f gettingstarted \u221f resources \u221f static pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/pom.xml 1-} We add several dependencies:- Spring Boot Starter Web provides the web server framework Spring Security provides the security framework Spring Boot Starter Data JPA will provide a relational database to store the metadata of our documents. In this case we are using the H2 in-memory database Spring Boot Starter Content FS will provide Filesystem-based storage for the content of each document and manage its association with a Document Entity Spring Versions JPA adds the ability to create new versions of a Document Spring Content CMIS provides the ability to export Document and Folder Entities via CMIS browser bindings. Create an Application class We need to initialize various aspects of our application. First we'll add the usual Spring Boot Application class. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Let's talk through the annotations: @SpringBootApplication needs no explanation @EnableCmis enables the cmis bindings. The most important attribute is basePackages. This tells the Spring Content CMIS module which packages to scan for Entities with @Cmis annotations. We'll see these presently. @Import imports the Spring Versions JPA standard configuration @EnableJpaRepositories tells Spring Data which packages to scan for Spring Data JPA Entities. We need to add this annotation in order to instruct Spring Data to scan the org.springframework.versions package (where it will find the LockingAndVersioningRepository fragment implementation) in addition to the gettingstarted package. @EnableFilesystemStores enables Spring Content Filesystem Storage. Technically, this is not required but added for clarity. You will also see that this application enables Spring Security setting up a single user test with a password of test . As well as entity auditing that we use to timestamp entity creation and modification. Define a BaseObject We are going to model both Documents and Folders and they share some common characteristics so let's define a BaseObject that they can both inherit from: src/main/java/gettingstarted/BaseObject.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/BaseObject.java 1-} As you would expect we created a standard JPA Entity to capture some common metadata; name and description . Standard audit metadata; createdBy , createdDate , modifiedBy , modifiedDate , and a revision stamp; vstamp . Lastly, we create a many-to-one relationship to a parent folder. You will notice that several of these fields are annotated with @Cmis annotations. @CmisName and @CmisDescription map these fields to their respective cmis fields. @CmisReference is a special reference that instructs Spring Content CMIS that this is part of a parent/child relationship. Create a Folder Entity Next, we'll create the Folder entity. As you would expect a Folder is a containing object allowing users to arrange their documents hierarchically. src/main/java/gettingstarted/Folder.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/Folder.java 1-} Note the @CmisFolder annotation that maps this entity to the cmis:folder object type. Also note the @CmisReference annotation instructing Spring Content CMIS that this is the other end of the parent/child relationship. Create a Document entity Lastly, we'll create the Document entity. src/main/java/gettingstarted/Document.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/Document.java 1-} Again, note the @CmisDocument that maps this entity to the cmis:document object type. We also see the standard Spring Versions JPA annotations for capturing version metadata as Documents are versioned. Create Repositories and Storage For both Folder and Document we create Repository interfaces: public interface FolderRepository extends JpaRepository<Folder, Long> { } public interface DocumentRepository extends JpaRepository<Document, Long>, LockingAndVersioningRepository<Document, Long> { } The DocumentRepository extends LockingAndVersioningRepository making Documents versionable. And, of course, we create a Storage interface for Documents: public interface DocumentStorage extends ContentStore<Document, UUID> { Build an executable JAR That's it. That's all you need. So let's take our application for a spin. If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-cmis-0.0.1.jar Use the CMIS Workbench to test the application We'll use the CMIS Workbench from the Apache Chemistry project to test the application. The workbench can be downloaded from here . Due to this bug , Java 8 is required. Download and run the workbench; i.e. ./workbench.sh . Spring Content CMIS exports the CMIS browser bindings to the /browser endpoint therefore the URL is http://localhost:8080/browser and the binding type is Browser . The username and password, as per the SecurityConfig , is test/test . Click Load Repositores and you should see this: This information should match the information provided in the Application class. Click Login and you should see something like this: Let's create a folder. Click Create Object -> Folder . Enter test-folder as the name and click Create Folder . You'll see the folder in the navigation pane. Double-click on the folder to navigate into it. Select the Properties tab to view its properties. Now, let's create a Document in this Folder. Click Create Object -> Document . Enter test-document as the name and generate 100 bytes of content. Click Create Document . Let's take a look at its content. Double-click on the document in the navigator to open the content in a new window. Earlier we made our Entity's versionable by having our DocumentRepository extend LockingAndVersioningRepository so let's create a new version of this document. Make sure the document is selected in the navigator. Select the Actions tab and Check-out Object . Now you should see two documents in your navigator. One blue, the original. One green, a private working copy of the new version. Usually, a user would iterate on their content and save it by setting the content stream. All of which is private to them. For simplicity we'll skip this step and go straight to checking in. In the Check-in Object panel select a local file and Check-in . Investigate the properties of both versions to see how they are related. You should see that they share the same version series id and in fact one of them, the first we created, is that document. Also note, the content streams IDs are different and when viewed you, in fact, do see different content. Summary Congratulations! You\u2019ve written a simple application that uses Spring Content CMIS.","title":"CMIS"},{"location":"spring-content-with-cmis-docs/#getting-started-with-spring-content-and-cmis-spring-content-2x-only-deprecated","text":"","title":"Getting Started with Spring Content and CMIS (Spring Content 2.x only - Deprecated)"},{"location":"spring-content-with-cmis-docs/#what-youll-build","text":"You'll build a simple document management application using Spring Content and Spring Content CMIS.","title":"What you'll build"},{"location":"spring-content-with-cmis-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.","title":"What you'll need"},{"location":"spring-content-with-cmis-docs/#how-to-complete-this-guide","text":"Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Build with Maven. To skip the basics, do the following: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git cd into spring-content-gettingstarted/spring-content-with-cmis/initial Jump ahead to Define a simple entity . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-cmis/complete .","title":"How to complete this guide"},{"location":"spring-content-with-cmis-docs/#build-with-maven","text":"First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with Maven is included here. If you\u2019re not familiar with Maven, refer to Building Java Projects with Maven .","title":"Build with Maven"},{"location":"spring-content-with-cmis-docs/#create-a-directory-structure","text":"In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/gettingstarted on *nix systems: \u221f src \u221f main \u221f java \u221f gettingstarted \u221f resources \u221f static pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/pom.xml 1-} We add several dependencies:- Spring Boot Starter Web provides the web server framework Spring Security provides the security framework Spring Boot Starter Data JPA will provide a relational database to store the metadata of our documents. In this case we are using the H2 in-memory database Spring Boot Starter Content FS will provide Filesystem-based storage for the content of each document and manage its association with a Document Entity Spring Versions JPA adds the ability to create new versions of a Document Spring Content CMIS provides the ability to export Document and Folder Entities via CMIS browser bindings.","title":"Create a directory structure"},{"location":"spring-content-with-cmis-docs/#create-an-application-class","text":"We need to initialize various aspects of our application. First we'll add the usual Spring Boot Application class. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Let's talk through the annotations: @SpringBootApplication needs no explanation @EnableCmis enables the cmis bindings. The most important attribute is basePackages. This tells the Spring Content CMIS module which packages to scan for Entities with @Cmis annotations. We'll see these presently. @Import imports the Spring Versions JPA standard configuration @EnableJpaRepositories tells Spring Data which packages to scan for Spring Data JPA Entities. We need to add this annotation in order to instruct Spring Data to scan the org.springframework.versions package (where it will find the LockingAndVersioningRepository fragment implementation) in addition to the gettingstarted package. @EnableFilesystemStores enables Spring Content Filesystem Storage. Technically, this is not required but added for clarity. You will also see that this application enables Spring Security setting up a single user test with a password of test . As well as entity auditing that we use to timestamp entity creation and modification.","title":"Create an Application class"},{"location":"spring-content-with-cmis-docs/#define-a-baseobject","text":"We are going to model both Documents and Folders and they share some common characteristics so let's define a BaseObject that they can both inherit from: src/main/java/gettingstarted/BaseObject.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/BaseObject.java 1-} As you would expect we created a standard JPA Entity to capture some common metadata; name and description . Standard audit metadata; createdBy , createdDate , modifiedBy , modifiedDate , and a revision stamp; vstamp . Lastly, we create a many-to-one relationship to a parent folder. You will notice that several of these fields are annotated with @Cmis annotations. @CmisName and @CmisDescription map these fields to their respective cmis fields. @CmisReference is a special reference that instructs Spring Content CMIS that this is part of a parent/child relationship.","title":"Define a BaseObject"},{"location":"spring-content-with-cmis-docs/#create-a-folder-entity","text":"Next, we'll create the Folder entity. As you would expect a Folder is a containing object allowing users to arrange their documents hierarchically. src/main/java/gettingstarted/Folder.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/Folder.java 1-} Note the @CmisFolder annotation that maps this entity to the cmis:folder object type. Also note the @CmisReference annotation instructing Spring Content CMIS that this is the other end of the parent/child relationship.","title":"Create a Folder Entity"},{"location":"spring-content-with-cmis-docs/#create-a-document-entity","text":"Lastly, we'll create the Document entity. src/main/java/gettingstarted/Document.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-cmis/complete/src/main/java/gettingstarted/Document.java 1-} Again, note the @CmisDocument that maps this entity to the cmis:document object type. We also see the standard Spring Versions JPA annotations for capturing version metadata as Documents are versioned.","title":"Create a Document entity"},{"location":"spring-content-with-cmis-docs/#create-repositories-and-storage","text":"For both Folder and Document we create Repository interfaces: public interface FolderRepository extends JpaRepository<Folder, Long> { } public interface DocumentRepository extends JpaRepository<Document, Long>, LockingAndVersioningRepository<Document, Long> { } The DocumentRepository extends LockingAndVersioningRepository making Documents versionable. And, of course, we create a Storage interface for Documents: public interface DocumentStorage extends ContentStore<Document, UUID> {","title":"Create Repositories and Storage"},{"location":"spring-content-with-cmis-docs/#build-an-executable-jar","text":"That's it. That's all you need. So let's take our application for a spin. If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-cmis-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-cmis-docs/#use-the-cmis-workbench-to-test-the-application","text":"We'll use the CMIS Workbench from the Apache Chemistry project to test the application. The workbench can be downloaded from here . Due to this bug , Java 8 is required. Download and run the workbench; i.e. ./workbench.sh . Spring Content CMIS exports the CMIS browser bindings to the /browser endpoint therefore the URL is http://localhost:8080/browser and the binding type is Browser . The username and password, as per the SecurityConfig , is test/test . Click Load Repositores and you should see this: This information should match the information provided in the Application class. Click Login and you should see something like this: Let's create a folder. Click Create Object -> Folder . Enter test-folder as the name and click Create Folder . You'll see the folder in the navigation pane. Double-click on the folder to navigate into it. Select the Properties tab to view its properties. Now, let's create a Document in this Folder. Click Create Object -> Document . Enter test-document as the name and generate 100 bytes of content. Click Create Document . Let's take a look at its content. Double-click on the document in the navigator to open the content in a new window. Earlier we made our Entity's versionable by having our DocumentRepository extend LockingAndVersioningRepository so let's create a new version of this document. Make sure the document is selected in the navigator. Select the Actions tab and Check-out Object . Now you should see two documents in your navigator. One blue, the original. One green, a private working copy of the new version. Usually, a user would iterate on their content and save it by setting the content stream. All of which is private to them. For simplicity we'll skip this step and go straight to checking in. In the Check-in Object panel select a local file and Check-in . Investigate the properties of both versions to see how they are related. You should see that they share the same version series id and in fact one of them, the first we created, is that document. Also note, the content streams IDs are different and when viewed you, in fact, do see different content.","title":"Use the CMIS Workbench to test the application"},{"location":"spring-content-with-cmis-docs/#summary","text":"Congratulations! You\u2019ve written a simple application that uses Spring Content CMIS.","title":"Summary"},{"location":"spring-content-with-encryption-docs/","text":"Getting Started Spring Content with Encryption What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ Docker Desktop (for the vault test container) How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you're finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-encryption/complete . Update dependencies Add the com.github.paulcwarren:spring-content-encryption dependency. This provides us the implementation of a EncryptingContentStore. Also add org.testcontainers:vault:1.17.6 . We are going to use vault to provide a keyring for encrypting the content encryption key which in turn is used to encrypt the content. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/pom.xml 1-60} Vault TestContainer First we add a simple class that creates and starts a vault test container upon demand. The vault is configured with a vault token root-token (referenced later) and enables the transit module that provides cryptographic functions to the encrypting content store. src/main/java/gettingstarted/VaultContainerSupport.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/VaultContainerSupport.java 1-} Configuration Next we need to introduce a small Configuration class to provide a vault endpoint to our application as well as configuring our encrypting content store. We add the following @Configuration to our SpringContentApplication . src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Points to note: - the clientAuthentication references the root-token - the encrypter bean creates an instance an EnvelopeEncryptionService . This is used by the EncyptingContentStore to provide envelope encryption on the content. - the config bean configures the EnryptingContentStore specifying the vault keyring to use to encrypt the content encryption key and the content property attribute to use to store that encrypted key for later use when decrypting content. Update File Update File to add the new content property attribute called key that will store the encrypted content encryption key. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/File.java 1-} Update FileContentStore Decorate the FileContentStore as an EncryptingContentStore to enable encryption/decryption on the content. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-encryption-0.0.1.jar As the application starts up look for the root of the filesystem storage. We'll look in here shortly to check content is encrypted. Look for the log entry that starts Default filesystem storage to ... and copy the file path. e.g. 2022-12-06 21:45:14.180 INFO 89223 --- [ main] o.s.c.fs.io.FileSystemResourceLoader : Defaulting filesystem root to /var/folders/65/d8zxcwh13sjfrkry92vgs5x80000gr/T/13946690314057106966 Test Encryption Create an entity: $ curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: $ curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1/content Get the content id: $ curl -X GET -H 'Accept:application/hal+json' http://localhost:8080/files/1 { \"name\" : null, \"created\" : \"2022-12-07T05:47:42.356+00:00\", \"summary\" : null, \"contentId\" : \"2d654dfc-57dc-44b7-aad9-f9ad0701c5d1\", \"contentLength\" : 27, \"contentMimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"content\" : { \"href\" : \"http://localhost:8080/files/1/content\" } } } Copy the contentId Check the content is encrypted: $ cat /var/folders/65/d8zxcwh13sjfrkry92vgs5x80000gr/T/13946690314057106966/<contnetId> i.e. $ cat /var/folders/65/d8zxcwh13sjfrkry92vgs5x80000gr/T/13946690314057106966/2d654dfc-57dc-44b7-aad9-f9ad0701c5d1 \ufffd\ufffdH\ufffd}\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0625\ufffd.\ufffd\ufffd^ Fetch the content: $ curl -H 'Accept:text/plain' http://localhost:8080/files/1/content Hello Spring Content World! Summary Congratulations! You've just written a simple application that uses Spring Content and Spring Content Encryption to be store content encrypted. Spring Content Encryption is also capable of serving bytes ranges. The default implementation uses AES CTR encryption and when used with Spring Content S3 will decrypt and serve just the byte ranges. With any other storage the content will be fully decrypted before serving the byte range.","title":"Encryption"},{"location":"spring-content-with-encryption-docs/#getting-started-spring-content-with-encryption","text":"","title":"Getting Started Spring Content with Encryption"},{"location":"spring-content-with-encryption-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-encryption-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ Docker Desktop (for the vault test container)","title":"What you'll need"},{"location":"spring-content-with-encryption-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you're finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-encryption/complete .","title":"How to complete this guide"},{"location":"spring-content-with-encryption-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-encryption dependency. This provides us the implementation of a EncryptingContentStore. Also add org.testcontainers:vault:1.17.6 . We are going to use vault to provide a keyring for encrypting the content encryption key which in turn is used to encrypt the content. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/pom.xml 1-60}","title":"Update dependencies"},{"location":"spring-content-with-encryption-docs/#vault-testcontainer","text":"First we add a simple class that creates and starts a vault test container upon demand. The vault is configured with a vault token root-token (referenced later) and enables the transit module that provides cryptographic functions to the encrypting content store. src/main/java/gettingstarted/VaultContainerSupport.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/VaultContainerSupport.java 1-}","title":"Vault TestContainer"},{"location":"spring-content-with-encryption-docs/#configuration","text":"Next we need to introduce a small Configuration class to provide a vault endpoint to our application as well as configuring our encrypting content store. We add the following @Configuration to our SpringContentApplication . src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Points to note: - the clientAuthentication references the root-token - the encrypter bean creates an instance an EnvelopeEncryptionService . This is used by the EncyptingContentStore to provide envelope encryption on the content. - the config bean configures the EnryptingContentStore specifying the vault keyring to use to encrypt the content encryption key and the content property attribute to use to store that encrypted key for later use when decrypting content.","title":"Configuration"},{"location":"spring-content-with-encryption-docs/#update-file","text":"Update File to add the new content property attribute called key that will store the encrypted content encryption key. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/File.java 1-}","title":"Update File"},{"location":"spring-content-with-encryption-docs/#update-filecontentstore","text":"Decorate the FileContentStore as an EncryptingContentStore to enable encryption/decryption on the content. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-encryption/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-with-encryption-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-encryption-0.0.1.jar As the application starts up look for the root of the filesystem storage. We'll look in here shortly to check content is encrypted. Look for the log entry that starts Default filesystem storage to ... and copy the file path. e.g. 2022-12-06 21:45:14.180 INFO 89223 --- [ main] o.s.c.fs.io.FileSystemResourceLoader : Defaulting filesystem root to /var/folders/65/d8zxcwh13sjfrkry92vgs5x80000gr/T/13946690314057106966","title":"Build an executable JAR"},{"location":"spring-content-with-encryption-docs/#test-encryption","text":"Create an entity: $ curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: $ curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1/content Get the content id: $ curl -X GET -H 'Accept:application/hal+json' http://localhost:8080/files/1 { \"name\" : null, \"created\" : \"2022-12-07T05:47:42.356+00:00\", \"summary\" : null, \"contentId\" : \"2d654dfc-57dc-44b7-aad9-f9ad0701c5d1\", \"contentLength\" : 27, \"contentMimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/1\" }, \"content\" : { \"href\" : \"http://localhost:8080/files/1/content\" } } } Copy the contentId Check the content is encrypted: $ cat /var/folders/65/d8zxcwh13sjfrkry92vgs5x80000gr/T/13946690314057106966/<contnetId> i.e. $ cat /var/folders/65/d8zxcwh13sjfrkry92vgs5x80000gr/T/13946690314057106966/2d654dfc-57dc-44b7-aad9-f9ad0701c5d1 \ufffd\ufffdH\ufffd}\ufffd\ufffdl\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0625\ufffd.\ufffd\ufffd^ Fetch the content: $ curl -H 'Accept:text/plain' http://localhost:8080/files/1/content Hello Spring Content World!","title":"Test Encryption"},{"location":"spring-content-with-encryption-docs/#summary","text":"Congratulations! You've just written a simple application that uses Spring Content and Spring Content Encryption to be store content encrypted. Spring Content Encryption is also capable of serving bytes ranges. The default implementation uses AES CTR encryption and when used with Spring Content S3 will decrypt and serve just the byte ranges. With any other storage the content will be fully decrypted before serving the byte range.","title":"Summary"},{"location":"spring-content-with-fulltext-docs/","text":"Getting Started Spring Content with Fulltext What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete . Update dependencies Add the com.github.paulcwarren:spring-content-elasticsearch-boot-starter and org.elasticsearch.client:elasticsearch-rest-high-level-client dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-fulltext/complete/pom.xml 1-} Update FileContentStore So that we can perform full-text searches make your FileContentStore extend Searchable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-fulltext/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar Start an Elasticsearch Server Using docker, start an elasticsearch server: docker run -d -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" paulcwarren/elasticsearch:latest Create an Entity Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring World!' http://localhost:8080/files/1/content Create a second entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with the second entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/2/content Perform a fulltext search using the /searchContent endpoint: curl -H 'Accept:application/hal+json' http://localhost:8080/files/searchContent?queryString=Content And you should see a response like this: { \"_embedded\" : { \"files\" : [ { \"name\" : null, \"created\" : \"2020-05-14T06:05:07.633+0000\", \"summary\" : null, \"contentId\" : \"527638d0-4f08-469d-a7d7-b271316af3da\", \"contentLength\" : 27, \"mimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"files\" : { \"href\" : \"http://localhost:8080/files/2\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/searchContent?queryString=Content\" } } } Spring Content found the second document that we added because its content included the keyword \"Content\" that we searched for. Summary Congratulations! You've just written a simple application that uses Spring Content with Elasticsearch to index content so that searches can be performed against that content. This guide demonstrates the Spring Content Elasticsearch Module. Spring Content also supports Solr with the Spring Content Solr Module. To use Solr, simply update the spring-content-elasticsearch-boot-starter dependency for spring-content-solr-boot-starter .","title":"Fulltext"},{"location":"spring-content-with-fulltext-docs/#getting-started-spring-content-with-fulltext","text":"","title":"Getting Started Spring Content with Fulltext"},{"location":"spring-content-with-fulltext-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-fulltext-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-fulltext-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete .","title":"How to complete this guide"},{"location":"spring-content-with-fulltext-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-elasticsearch-boot-starter and org.elasticsearch.client:elasticsearch-rest-high-level-client dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-fulltext/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-fulltext-docs/#update-filecontentstore","text":"So that we can perform full-text searches make your FileContentStore extend Searchable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-fulltext/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-with-fulltext-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-fulltext-docs/#start-an-elasticsearch-server","text":"Using docker, start an elasticsearch server: docker run -d -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" paulcwarren/elasticsearch:latest","title":"Start an Elasticsearch Server"},{"location":"spring-content-with-fulltext-docs/#create-an-entity","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring World!' http://localhost:8080/files/1/content Create a second entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with the second entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/2/content Perform a fulltext search using the /searchContent endpoint: curl -H 'Accept:application/hal+json' http://localhost:8080/files/searchContent?queryString=Content And you should see a response like this: { \"_embedded\" : { \"files\" : [ { \"name\" : null, \"created\" : \"2020-05-14T06:05:07.633+0000\", \"summary\" : null, \"contentId\" : \"527638d0-4f08-469d-a7d7-b271316af3da\", \"contentLength\" : 27, \"mimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"files\" : { \"href\" : \"http://localhost:8080/files/2\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/searchContent?queryString=Content\" } } } Spring Content found the second document that we added because its content included the keyword \"Content\" that we searched for.","title":"Create an Entity"},{"location":"spring-content-with-fulltext-docs/#summary","text":"Congratulations! You've just written a simple application that uses Spring Content with Elasticsearch to index content so that searches can be performed against that content. This guide demonstrates the Spring Content Elasticsearch Module. Spring Content also supports Solr with the Spring Content Solr Module. To use Solr, simply update the spring-content-elasticsearch-boot-starter dependency for spring-content-solr-boot-starter .","title":"Summary"},{"location":"spring-content-with-rbac-docs/","text":"Getting Started Spring Content with RBAC What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-rbac/complete . Update dependencies Add org.springframework.boot:spring-boot-starter-security dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-rbac/complete/pom.xml 1-} Add Security Constraints Enable web security. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-rbac/complete/src/main/java/gettingstarted/SpringSecurityConfig.java 1-} First, define two users and two roles. Eric is a content reader and Paul is a content reader and author . Second, secure the Spring Content endpoint /files/**/content that GETs and SETs content to the reader and author roles respectively. @PreAuthorize As an alternative secure removing content to the author role by using an alternative approach using the @PreAuthorize annotation on the FileContentStore's unset method. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-rbac/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-rbac-0.0.1.jar Create an Entity and version it Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Attempt to associate content as Eric: curl -u eric:wimp -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with RBAC World!' http://localhost:8080/files/1/content Associate content as Paul: curl -u paul:warren -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with RBAC World!' http://localhost:8080/files/1/content Fetch the content as Eric: curl -u eric:wimp -H 'Accept:text/plain' http://localhost:8080/files/1/content And as Paul: curl -u paul:warren -H 'Accept:text/plain' http://localhost:8080/files/1/content Attempt to delete content as Eric: curl -u eric:wimp -X DELETE http://localhost:8080/files/1/content Delete content as Paul: curl -u paul:warren -X DELETE http://localhost:8080/files/1/content Summary Congratulations! You've written a simple application that uses Spring Content secured with role-based access control. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage technology. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"RBAC"},{"location":"spring-content-with-rbac-docs/#getting-started-spring-content-with-rbac","text":"","title":"Getting Started Spring Content with RBAC"},{"location":"spring-content-with-rbac-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-rbac-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-rbac-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-rbac/complete .","title":"How to complete this guide"},{"location":"spring-content-with-rbac-docs/#update-dependencies","text":"Add org.springframework.boot:spring-boot-starter-security dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-rbac/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-rbac-docs/#add-security-constraints","text":"Enable web security. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-rbac/complete/src/main/java/gettingstarted/SpringSecurityConfig.java 1-} First, define two users and two roles. Eric is a content reader and Paul is a content reader and author . Second, secure the Spring Content endpoint /files/**/content that GETs and SETs content to the reader and author roles respectively.","title":"Add Security Constraints"},{"location":"spring-content-with-rbac-docs/#preauthorize","text":"As an alternative secure removing content to the author role by using an alternative approach using the @PreAuthorize annotation on the FileContentStore's unset method. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-rbac/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"@PreAuthorize"},{"location":"spring-content-with-rbac-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-rbac-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-rbac-docs/#create-an-entity-and-version-it","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Attempt to associate content as Eric: curl -u eric:wimp -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with RBAC World!' http://localhost:8080/files/1/content Associate content as Paul: curl -u paul:warren -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with RBAC World!' http://localhost:8080/files/1/content Fetch the content as Eric: curl -u eric:wimp -H 'Accept:text/plain' http://localhost:8080/files/1/content And as Paul: curl -u paul:warren -H 'Accept:text/plain' http://localhost:8080/files/1/content Attempt to delete content as Eric: curl -u eric:wimp -X DELETE http://localhost:8080/files/1/content Delete content as Paul: curl -u paul:warren -X DELETE http://localhost:8080/files/1/content","title":"Create an Entity and version it"},{"location":"spring-content-with-rbac-docs/#summary","text":"Congratulations! You've written a simple application that uses Spring Content secured with role-based access control. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage technology. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"},{"location":"spring-content-with-renditions-docs/","text":"Getting Started Spring Content with Fulltext What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete . Update dependencies Add the com.github.paulcwarren:spring-content-renditions-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/pom.xml 1-} Update File To be able to return renditions we need to know the mime-type of the existing content. Annotate the mimeType field with the MimeType annotation so that it will be by Spring Content REST. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/File.java 1-33} Update FileContentStore So that we can fetch renditions make your FileContentStore extend Renderable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-renditions-0.0.1.jar Test renditions Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1/content Fetch the content: curl -H 'Accept:text/plain' http://localhost:8080/files/1/content And you should see a response like this: Hello Spring Content World! Fetch the content again but this time specify that we want a jpeg rendition of the content by specify the mime-type image/jpeg as the accept header. Let's time the operation too. We'll use this later. As it is an image let's save it to a file: time curl -H 'Accept:image/jpeg' http://localhost:8080/files/1/content --output /tmp/file-1.jpg Note the time the operation tookk and inspect the image open /tmp/file-1.jpg and you should see an image like this: Stored Renditions This is useful but rendering content on-demand everytime is unnecessary. Let's store the rendition instead. Update File Add a second content property to store the rendition. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/File.java 1-} Add Event Handler Next let's add an event handler that uses the rendition service to convert the text/plain content to image/jpeg and store it in the second content property we just created. Then remove it again when the content is also removed. src/main/java/gettingstarted/StoredRenditionsEventHandler.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/StoredRenditionsEventHandler.java 1-} and register it. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Test Store Renditions Rebuild and restart your application and let's replay the operations we performed earlier. Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Stored Renditions World!' http://localhost:8080/files/1/content Fetch the content again specifying that we want a jpeg rendition of the content by specifying the mime-type image/jpeg as the accept header. Note, we are still addressing the 'content' property. Let's time the operation again. We can compare this to our previous timing. And for ease save it to a file: time curl -H 'Accept:image/jpeg' http://localhost:8080/files/1/content --output /tmp/file-1.jpg Note the time completed quicker (roughly twice as fast) as it was returning the previous stored rendition rather than converting it on the fly. Inspect the image by opening /tmp/file-2.jpg and you should see an image like this: Summary Congratulations! You've just written a simple application that uses Spring Content and Spring Content Renditions to be able to transform content from one format to another and to store that rendered content for quicker access later on. This guide demonstrates the Spring Content Renditions Module. This module supports several renderers out-of-the-box satisfying most use cases. However, you may also add your own renderers using the RenditionProvider extension point. For more details see the Spring Content Renditions reference guide.","title":"Renditions"},{"location":"spring-content-with-renditions-docs/#getting-started-spring-content-with-fulltext","text":"","title":"Getting Started Spring Content with Fulltext"},{"location":"spring-content-with-renditions-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-renditions-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-renditions-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete .","title":"How to complete this guide"},{"location":"spring-content-with-renditions-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-renditions-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-renditions-docs/#update-file","text":"To be able to return renditions we need to know the mime-type of the existing content. Annotate the mimeType field with the MimeType annotation so that it will be by Spring Content REST. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/File.java 1-33}","title":"Update File"},{"location":"spring-content-with-renditions-docs/#update-filecontentstore","text":"So that we can fetch renditions make your FileContentStore extend Renderable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-with-renditions-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-renditions-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-renditions-docs/#test-renditions","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1/content Fetch the content: curl -H 'Accept:text/plain' http://localhost:8080/files/1/content And you should see a response like this: Hello Spring Content World! Fetch the content again but this time specify that we want a jpeg rendition of the content by specify the mime-type image/jpeg as the accept header. Let's time the operation too. We'll use this later. As it is an image let's save it to a file: time curl -H 'Accept:image/jpeg' http://localhost:8080/files/1/content --output /tmp/file-1.jpg Note the time the operation tookk and inspect the image open /tmp/file-1.jpg and you should see an image like this:","title":"Test renditions"},{"location":"spring-content-with-renditions-docs/#stored-renditions","text":"This is useful but rendering content on-demand everytime is unnecessary. Let's store the rendition instead.","title":"Stored Renditions"},{"location":"spring-content-with-renditions-docs/#update-file_1","text":"Add a second content property to store the rendition. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/File.java 1-}","title":"Update File"},{"location":"spring-content-with-renditions-docs/#add-event-handler","text":"Next let's add an event handler that uses the rendition service to convert the text/plain content to image/jpeg and store it in the second content property we just created. Then remove it again when the content is also removed. src/main/java/gettingstarted/StoredRenditionsEventHandler.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/StoredRenditionsEventHandler.java 1-} and register it. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-renditions/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-}","title":"Add Event Handler"},{"location":"spring-content-with-renditions-docs/#test-store-renditions","text":"Rebuild and restart your application and let's replay the operations we performed earlier. Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Stored Renditions World!' http://localhost:8080/files/1/content Fetch the content again specifying that we want a jpeg rendition of the content by specifying the mime-type image/jpeg as the accept header. Note, we are still addressing the 'content' property. Let's time the operation again. We can compare this to our previous timing. And for ease save it to a file: time curl -H 'Accept:image/jpeg' http://localhost:8080/files/1/content --output /tmp/file-1.jpg Note the time completed quicker (roughly twice as fast) as it was returning the previous stored rendition rather than converting it on the fly. Inspect the image by opening /tmp/file-2.jpg and you should see an image like this:","title":"Test Store Renditions"},{"location":"spring-content-with-renditions-docs/#summary","text":"Congratulations! You've just written a simple application that uses Spring Content and Spring Content Renditions to be able to transform content from one format to another and to store that rendered content for quicker access later on. This guide demonstrates the Spring Content Renditions Module. This module supports several renderers out-of-the-box satisfying most use cases. However, you may also add your own renderers using the RenditionProvider extension point. For more details see the Spring Content Renditions reference guide.","title":"Summary"},{"location":"spring-content-with-versions-docs/","text":"Getting Started Spring Content with Versions What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-versions/complete . Update dependencies Add the com.github.paulcwarren:spring-versions-boot-starter and org.springframework.boot:spring-boot-starter-security dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/pom.xml 1-} Update File Entity Add the following annotations to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/File.java 1-} @LockOwner ; tracks the current lock owner. Optional @AncestorId ; references the entity that came immediately before in the version series @AncestorRootId ; references the entity that came first in the version series @SuccessorId ; references the entity that came after in the version series @VersionNumber ; version designation @VersionLabel ; description of the version Also note the copy constructor. An Entity can be complex. It is impossible for Spring Content to know exactly how to stamp out a new version when it needs to. This is where the copy constructor comes in. The copy constructor tells Spring Content how to create a new version. There is no need to copy the version attributes as they will be managed as part of the version creation process. Other than that, it is up to you. Update FileRepository So that we can perform version operations on an Entity make your FileRepository extend LockingAndVersioningRepository . src/main/java/gettingstarted/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/FileRepository.java 1-} Update Configuratoin Add a Store configuration to tell Spring Data JPA to look in the package org.springframework.versions for the implementation of the LockingAndVersioningRepository . Because of this you will also need to tell Spring Data to find FileRepository in the gettingstarted package. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 29-32} Enable web security and add an anonymous user principal. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 34-79} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar Create an Entity and version it Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with Versions World!' http://localhost:8080/files/1 Lock the Entity to prevent others from editing it: curl -X PUT -H 'Content-Type:application/hal+json' http://localhost:8080/files/1/lock Create a new version of the entity: curl -X PUT -H 'Content-Type:application/hal+json' -d '{\"number\":\"1.1\",\"label\":\"some minor changes\"}' http://localhost:8080/files/1/version Unlock the new version of the Entity: curl -X DELETE -H 'Accept:application/hal+json' http://localhost:8080/files/2/lock Fetch the version series: curl -H 'Accept:application/hal+json' http://localhost:8080/files/ Verify you now see two entities that are in a version series with each other. Summary Congratulations! You've written a simple application that uses Spring Content with Versions to create a version series of entities with associated content. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage technology. The REST and Version Modules works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Versions"},{"location":"spring-content-with-versions-docs/#getting-started-spring-content-with-versions","text":"","title":"Getting Started Spring Content with Versions"},{"location":"spring-content-with-versions-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-versions-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-versions-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-versions/complete .","title":"How to complete this guide"},{"location":"spring-content-with-versions-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-versions-boot-starter and org.springframework.boot:spring-boot-starter-security dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-versions-docs/#update-file-entity","text":"Add the following annotations to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/File.java 1-} @LockOwner ; tracks the current lock owner. Optional @AncestorId ; references the entity that came immediately before in the version series @AncestorRootId ; references the entity that came first in the version series @SuccessorId ; references the entity that came after in the version series @VersionNumber ; version designation @VersionLabel ; description of the version Also note the copy constructor. An Entity can be complex. It is impossible for Spring Content to know exactly how to stamp out a new version when it needs to. This is where the copy constructor comes in. The copy constructor tells Spring Content how to create a new version. There is no need to copy the version attributes as they will be managed as part of the version creation process. Other than that, it is up to you.","title":"Update File Entity"},{"location":"spring-content-with-versions-docs/#update-filerepository","text":"So that we can perform version operations on an Entity make your FileRepository extend LockingAndVersioningRepository . src/main/java/gettingstarted/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/FileRepository.java 1-}","title":"Update FileRepository"},{"location":"spring-content-with-versions-docs/#update-configuratoin","text":"Add a Store configuration to tell Spring Data JPA to look in the package org.springframework.versions for the implementation of the LockingAndVersioningRepository . Because of this you will also need to tell Spring Data to find FileRepository in the gettingstarted package. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 29-32} Enable web security and add an anonymous user principal. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/main/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 34-79}","title":"Update Configuratoin"},{"location":"spring-content-with-versions-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-versions-docs/#create-an-entity-and-version-it","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with Versions World!' http://localhost:8080/files/1 Lock the Entity to prevent others from editing it: curl -X PUT -H 'Content-Type:application/hal+json' http://localhost:8080/files/1/lock Create a new version of the entity: curl -X PUT -H 'Content-Type:application/hal+json' -d '{\"number\":\"1.1\",\"label\":\"some minor changes\"}' http://localhost:8080/files/1/version Unlock the new version of the Entity: curl -X DELETE -H 'Accept:application/hal+json' http://localhost:8080/files/2/lock Fetch the version series: curl -H 'Accept:application/hal+json' http://localhost:8080/files/ Verify you now see two entities that are in a version series with each other.","title":"Create an Entity and version it"},{"location":"spring-content-with-versions-docs/#summary","text":"Congratulations! You've written a simple application that uses Spring Content with Versions to create a version series of entities with associated content. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage technology. The REST and Version Modules works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"}]}